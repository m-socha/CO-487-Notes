\documentclass[12pt,titlepage]{article}
\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage{float}

\let\stdsection\section
\renewcommand\section{\clearpage\stdsection}

\usepackage{hyperref}
\hypersetup{
  linktoc=all
}

\begin{document}
  \begin{titlepage}
    \vspace*{\fill}
    \centering

    \textbf{\Huge CO 487 Course Notes} \\ [0.4em]
    \textbf{\Large Applied Cryptography} \\ [1em]
    \textbf{\Large Michael Socha} \\ [1em]
    \textbf{\large University of Waterloo} \\
    \textbf{\large Winter 2019} \\
    \vspace*{\fill}
  \end{titlepage}

  \newpage 

  \pagenumbering{roman}

  \tableofcontents

  \newpage

  \pagenumbering{arabic}

  \section{Course Overview}
    This course is an applied introduction to modern cryptography. Topics covered include:
    \begin{itemize}
      \item Symmetric-key encryption
      \item Hash functions
      \item Authenticated encryption
      \item Public-key encryption
      \item Signature schemes
      \item Key establishment
      \item Key management
      \item Examples of deployed cryptography (e.g. SSL, cryptocurrencies, WPA)
    \end{itemize}

  \section{Introduction - What is Cryptography?}
    Information security (also known as cybersecurity) deals with protecting information assets from
    unauthorized acquisition, damage, disclosure, manipulation, loss, or use. Cryptography deals with
    the mathematical, algorithmic and implementation aspects of information security.

    Cybersecurity more broadly includes the study of computer security, network security and software
    security.

    \subsection{Goals of Cryptography}
      In short, cryptography is about securing communications in the face of malicious adversaries.
      When describing cryptographic scenarios, Alice and Bob are used to indicate two parties who wish
      to communicate with one another across some channel, while Eve is a malicious adversary. Eve may
      attempt to read or modify the data being transmitted.

      The main goals of cryptography are to provide:
      \begin{itemize}
        \item \textbf{Confidentiality:} Keeps data secret from unauthorized entities.
        \item \textbf{Data integrity:} Ensures data has not been altered by unauthorized means.
        \item \textbf{Data origin authentication:} Determines the sender of data.
        \item \textbf{Non-repudiation:} Provides proof of data origin and integrity, which can be
          used to prevent senders from disputing a previous action.
      \end{itemize}

  \section{Symmetric-Key Encryption}

    \subsection{Introduction}
      A symmetric-key encryption scheme (SKES) consists of:
      \begin{itemize}
        \item $M$ - the plaintext space
        \item $C$ - the ciphertext space
        \item $K$ - the key space
        \item a family of encryption functions - $\forall k \in K, E_k : M \rightarrow C$
        \item a family of decryption functions - $\forall k \in K, D_k : C \rightarrow M$, such that
          $\forall k \in K, \forall m \in M, D_k(E_k(m)) = m$
      \end{itemize}

      The idea behind using SKES to achieve confidentiality is:
        \begin{enumerate}
          \item Alice and Bob agree on a secret key $k$ (note that this cannot be done over an unsecured
            channel, or Eve may read the key).
          \item Alice computes $c = E_k(m)$, and sends Bob ciphertext $c$, which is an encrypted form of the plaintext $m$.
          \item Bob computes $m = D_k(c)$ to retrieve the plaintext $m$.
        \end{enumerate}

    \subsection{SKES Security}
      A security model defines the computational power of an adversary, and how they interact with the communicating parties.
      It is generally assumes that the adversary knows everything about the SKES besides the value of $k$.

      \subsubsection{Types of Attacks (Adversary Interactions)}
        \begin{itemize}
          \item \textbf{Passive Attacks:}
            \begin{itemize}
              \item Ciphertext-only attack - Eve only knows some ciphertext generated by Alice and Bob.
              \item Known-plaintext attack - Eve knows some plaintext and the corresponding ciphertext.
            \end{itemize}
          \item \textbf{Active Attacks:}
            \begin{itemize}
              \item Chosen-plaintext attack - Eve can choose some plaintext and obtain the corresponding ciphertext.
            \end{itemize}
          \item \textbf{Other Attacks:}
            \begin{itemize}
              \item Clandestine attacks - Bribery, blackmail, etc.
              \item Side-channel attackers - Involves monitoring of encryption and decryption equipment.
            \end{itemize}
        \end{itemize}

      \subsubsection{Computational Power of Adversary}
        \begin{itemize}
          \item \textbf{Information-theoretic security:} Eve has infinite computational resources.
          \item \textbf{Complexity-theoretic security:} Eve has a polynomial-time Turing Machine.
          \item \textbf{Computational Security:} Eve has some fixed amount of computing power.
        \end{itemize}

      \subsubsection{Goal of Adversary}
        The adversary may try to:
        \begin{enumerate}
          \item Recover the secret key.
          \item Systematically recover plaintext from ciphertext, though without necessarily knowing the key.
          \item Learn some information about plaintext based on its ciphertext (other than its length).
        \end{enumerate}

        If an adversary can succeed at 1 or 2, then the SKES is said to be completely/totally insecure. If none
        of these goals can be achieved, the SKES is said to be semantically secure.

      \subsubsection{Secure SKES}
        A SKES is said to be secure if it is semantically secure when attacked with a chosen-plaintext attack
        by a computationally-bounded adversary.

    \subsection{Desirable Properties for SKES}
      \begin{itemize}
        \item Efficient algorithms should be known for encryption and decryption functions.
        \item The secret key should be large enough to render exhaustive key search infeasible, though still relatively small.
        \item The scheme should be secure against everyone, even against the designers of the system (no security through obscurity).
      \end{itemize}

    \subsection{Security Level}
      A cryptographic schema is said to have a security level of $l$ bits if the fastest known attack scheme takes around $2^l$ operations.
      For context, in this course, we consider $2^{40}$ operations very feasible, $2^{80}$ barely feasible, and $2^{128}$ infeasible.
      Security levels of 128 bits are desirable in practice.

    \subsection{Some Simple Ciphers}

      \subsubsection{Simple Substitution Cipher}
        The simple substitution cipher involves replacing units of plaintext with ciphertext. For example, if the key is that $a$ maps to $Y$
        and $b$ maps to $Z$, then $m = abbba$ results in $c = YZZZY$.

        This cipher is totally insecure against a chosen-plaintext attack, since the mapping can be easily determined. When the mapping can be
        determined using character frequency analysis, it is also totally insecure against a ciphertext-only attack.

      \subsubsection{Polyalphabetic Cipher}
        The idea behind a polyalphabetic cipher is to allow a unit of plaintext to be encrypted to one of many possible ciphertext units. A
        common example is the Vigenere cipher, which uses modulo addition with a key. For example if the message is $thisisamessage$ and the
        key is $CRYPTO$, and the ciphertext is computer as follows:

        \begin{table}[H]
          \centering
          \begin{tabular}{ | c | c c c c c c c c c c c c c c | }
            \hline
            m = & t & h & i & s & i & s & a & m & e & s & s & a & g & e \\
            \hline
            k = & C & R & Y & P & T & O & C & R & Y & P & T & O & C & R \\
            \hline
            c = & V & Y & G & H & B & G & C & D & C & H & L & O & I & V \\
            \hline
          \end{tabular}
        \end{table}

        The Vigenere cipher is totally insecure against a chosen-plaintext attack, since the key can easily be figured out through modulo arithmetic.

      \subsubsection{One-Time Pad}
        The one-time pad uses modulo addition with a key at least as long as the message itself. For example, if the message is $message$
        and the key is $SMFJDLG$, the ciphertext can be computer as follows:

        \begin{table}[H]
          \centering
          \begin{tabular}{ | c | c c c c c c c | }
            \hline
            m = & m & e & s & s & a & g & e \\
            \hline
            k = & S & M & F & J & D & L & G \\
            \hline
            c = & F & Q & X & C & D & R & K \\
            \hline
          \end{tabular}
        \end{table}

        The one-time pad is like the Vigenere cipher, but a different key is used to encrypt each message. This makes the one-time pad semantically secure
        against a ciphertext-only attack, even by an adversary with unlimited resources. However, the one-time pad is impractical due to:
        \begin{enumerate}
          \item Its long key length
          \item Key reuse introducing a vulnerability (Since $c_1 = m_1 + k$ and $c_2 = m_2 + k$, $c_1 - c_2 = m_1 - m_2$, so if one message
            is known, another can be computed.
        \end{enumerate}

    \subsection{Stream Ciphers}
      As an alternative to using a random key, a pseudorandom bit generator (PRBG) can be used to generate a key. The PBRG is seeded with a
      secret value shared between Alice and Bob, and then generates new ``random-looking'' keys based on its previous state.

      \subsubsection{RC4 Cipher}
        RC4 is a simple, fast cipher for which no catastrophic weakness has been found. It consists of two components, namely a key scheduling algorithm
        and a keystream generator.

        The high-level idea of the key scheduling algorithm is to generate a random-looking permutation of 0 to 255 (stored in $S$) based on the secret
        key ($K$).

        \begin{verbatim}
          for i from 0 to 255
            S[i] := i // initialize to identity permutation

          j := 0
          for i from 0 to 255
            j := j + S[i] + K[i mod keylength] mod 256
            swap(S[i], S[j])
        \end{verbatim}

        The keystream generator accepts the permutation of $S$ resulting from the key scheduling algorithm as input. The keystream generator continues to
        modify $S$ while producing a bytestream.

        \begin{verbatim}
          i := 0
          j := 0
          while we need to generate another keystream byte
            i := (i + 1) mod 256
            j := (j + S[i]) mod 256
            swap(S[i], S[j])
            t := S[i] + S[j] mod 256
            output S[t]
        \end{verbatim}

        The keystream bytes are modulo added (i.e XORed) to the plaintext bytes to produce ciphertext bytes. There are known biases in the first few bytes
        of the keystream, so these bytes should be discarded.

        RC4 was used for applications such as SSL and WEP. More recently, several weaknesses have been discovered, so RC4 is no longer widely used.

    \subsection{Block Ciphers}
      Block ciphers break up a plaintext into fixed-size blocks, and then encrypt the blocks one at a time. In contrast, stream ciphers encrypt the plaintext
      one character at a time (i.e. blocks are of length 1).

      Some desirable properties of block ciphers are:
      \begin{itemize}
        \item \textbf{Diffusion:} Each ciphertext bit should depend on all plaintext bits.
        \item \textbf{Confusion:} The relationship between key bits and ciphertext bits should be complicated.
        \item \textbf{Algorithm simplicity}
        \item \textbf{Efficiency:} High speed of encryption and decryption.
      \end{itemize}

      \subsubsection{Feistel Ciphers}
        Feistel ciphers are a class of block ciphers with the following parameters:
        \begin{itemize}
          \item $n$ - half the block length
          \item $h$ - number of encryption rounds
          \item $l$ - key length
          \item $M = \{0, 1\}^{2n}, C = \{0, 1\}^{2n}, K = \{0, 1\}^{l}$
        \end{itemize}

        A key scheduling algorithm determines $h$ subkeys $k_1, k_2, ..., k_h$ from a key $k$. Each subkey $k_i$ defines a component function
        $f_i : \{0, 1\}^n \rightarrow \{0, 1\}^n$. Feistel ciphers encrypt by iteratively applying these component functions as follows:
        \begin{itemize}
          \item Plaintext is $m = (m_0, m_1)$
          \item Round 1 of encryption results in $(m_1, m_2)$, where $m_2 = m_0 \oplus f_1(m_1)$
          \item Round 2 of encryption results in $(m_2, m_3)$, where $m_3 = m_1 \oplus f_2(m_2)$
          \item . . .
          \item Ciphertext is $c = (m_h, m_{h+1})$
        \end{itemize}

        Decryption applies these functions in reverse order.

        \paragraph{New Data Seal (NDS)} is a type of Feistel cipher with $n = 64$ and $h = 16$. $k$ is a randomly selected function that converts one byte to
        another. Since there are 256 unique bytes, there are $256^{256} = 2^{2048}$ unique keys, so $l = 2048$. Subkeys $k_i$ are simply $k$ itself. The component
        function $f : \{0, 1\}^{64} \rightarrow \{0, 1\}^{64}$ is defined as follows:

        \begin{enumerate}
          \item Divide input $z$ into 8 bytes $(z_1, z_2, ..., z_8)$.
          \item Divide each byte $z_j$ into two nibbles $(n_1^j, n_2^j)$.
          \item Apply some publicly known operations $S_0$ to $n_1^j$ and $S_1$ to $n_2^j$ to produce new nibbles $p_1^j$ and $p_2^j$.
          \item Let $z^*$ be the byte obtained by taking the first bit of every byte. Compute $t = k(z^*)$.
          \item If the jth bit of $t$ is 1, then swap $p_1^j$ and $p_2^j$.
          \item Permute the resulting 64 bits by some publicly known operation $P$.
        \end{enumerate}

        The key of NDS can be determined after a chosen-plaintext attack of around 32,000 carefully selected inputs. Thus, NDS is totally insecure, which underlines
        the importance of using different subkeys for different rounds of a Feistel cipher.

        \paragraph{Data Encryption Standard (DES)} is a type of Feistel cipher with $n = 32$, $h = 16$ and $l = 56$. Unlike NDS, DES selects different subkeys for
        each round of encryption; each subkey is a selection of 48 bits of $k$.

        Although DES has been important in the development of modern cryptography, its short key length makes it susceptible to brute-force attacks. Another problem
        is the small block size $(2 \cdot 32 = 64)$, which means that a collision between ciphertext blocks is expected approximately every $\sqrt{2^{64}} = 2^{32}$
        blocks.

      \subsubsection{Multiple Encryption}
        Multiple encryption involves encrypting a message multiple times. For example, if DES encryption is done twice with independent keys, then $l = 2*56 = 112$, seemingly
        reducing the feasibility of exhaustive key search.

        However, so-called meet-in-the-middle attacks can be used to greatly reduce the security level of the encryption scheme. For example, if $c = E_{k2}(E_{k1}(m))$,
        then instead of performing $2^{2l}$ operations to find the key $(k_1, k_2)$, the result of $E_{k2}^{-1}(c)$ can be saved for all $2^l$ possible values of $k_2$. Then,
        $E_{k1}(m)$ can be run for all $2^l$ possible values of $k_1$, and then matches can be searched for such that $E_{k1}(m) = E_{k2}^{-1}(c)$. Thus, the security level
        of double encryption is roughly $2 \cdot 2^l = 2^{l + 1}$, making it not much more secure than single encryption.

        Triple encryption is more resistant to meet-in-the-middle attacks, requiring around $2^{2*56} = 2^{112}$ steps to break (i.e. ``middle'' here means two levels
        deep on one side and one level deep on the other). In light of its enhanced security, triple DES actually has some uses in production.

      \subsubsection{Modes of Operation}
        Modes of operation concern how to use a block cipher to encrypt some plaintext messages $m = m_1 m_2 . . . m_t$. The simplest mode is called electronic codebook
        (ECB) mode, where plaintext blocks map to ciphertext blocks independently of one another. Since identical plaintexts result in identical ciphertexts, ECB mode
        is not semantically secure against chosen-plaintext attacks.

        Cipher block chaining (CBC) mode involves each block of plaintext being XORed with the one encrypted before it. Since identical blocks of plaintext no longer map
        the the same ciphertext, CBC mode is secure against chosen-plaintext attacks.

    \subsection{Advanced Encryption Standard (AES)}
      AES is the most widely used production SKES. Established in 2001 by the US National Institute of Standards and Technology (NIST), AES is a block cipher using 128 bit
      blocks and supports key sizes of 128, 192, and 256 bits.

  \section{Hash Functions}
    A hash function is a mapping of a message of an arbitrary length to a message of fixed length. An n-bit hash function $H$ can be defined as
    $H : \{0, 1\}^{\leq L} \rightarrow \{0, 1\}^n$. Generally speaking, $L$ is very large while $n$ is fairly small. The output of a hash function is known as a hash value
    or message digest.

    \subsection{Desirable Properties}
      A few desirable properties hash functions for cryptography applications are:
      \begin{itemize}
        \item \textbf{Efficiency:} $H(x)$ can be computed quickly for all valid inputs $x$.
        \item \textbf{Preimage resistance:} Given a hash value $y \in \{0, 1\}^n$, it is computationally infeasible to find a value $x \in \{0, 1\}^{\leq L}$ such that
          $H(x) = y$ (i.e. the hash function is hard to reverse). This property allows the storage of hash values of sensitive data. For example, instead of storing
          passwords in plaintext, a login system can store hard-to-reverse hashes of passwords, and to login, the hash of the user's inputted password is compared to
          the stored hash.
        \item \textbf{Second preimage resistance:} Given an input $x \in \{0, 1\}^{\leq L}$, it is computationally infeasible to find another input $x' \in \{0, 1\}^{\leq L}$
          such that $H(x') = H(x)$. This property can be used to detect if a message is edited through unauthorized means.
        \item \textbf{Collision Resistance:} It is computationally infeasible to find two distinct inputs $x$ and $x'$ such that $H(x') = H(x)$. Such pairs $(x, x')$ are known
          as collisions. Collision resistance requires second preimage resistance as a precondition. Also, if $H$ is somewhat uniform (i.e. outputs have a roughly equal amount
          of corresponding inputs), then collision resistance guarantees preimage resistance.
      \end{itemize}

      A hash function that is preimage resistant is called a one-way hash function. A hash function with collision resistance is called a collision-resistant hash function.
      A hash function that is both preimage resistant and collision resistant is called a cryptographic hash function.

    \subsection{Generic Attacks}
      Generic attacks on hash functions are attacks that do not exploit any properties specific to a hash function (i.e. the hash function is simply treated as a random function).

      \subsubsection{Finding Preimages}
        To find a preimage for a hash value $y \in \{0, 1\}^n$, random values of $x \in \{0, 1\}^{\leq L}$ need to be selected until $H(x) = L$. The expected number of values of
        $x$ tested before a match is found is $2^n$, so this attack is computationally infeasible for large enough values of $n$ (e.g. 128).

      \subsubsection{Finding Collisions}
        To find collisions, random values $x \in \{0, 1\}^n$ can be saved along with $H(x)$. The expected number of values $x$ tested before a collision is found is roughly
        $\sqrt{2^n} = 2^{\frac{n}{2}}$.

    \subsection{Hash Functions from Block Ciphers}
      Hash functions can be constructed from block ciphers. An example of this is the Davies-Meyer hash function, which works by splitting a message into fixed-sized blocks
      that serve as keys for a block cipher, and then iteratively feeding the results of these block ciphers into one another. The Davies-Meyer hash function is defined as
      follows:
      \begin{itemize}
        \item Let $H_0$ be some initializing value $IV$
        \item Let $E_k$ be an m-bit block cipher with an n-bit key $k$
        \item Let a message $x$ be broken up into $t$ n-bit blocks: $x = x_1x_2 . . . x_t$
        \item $H_i = E_{x_i}(H_{i-1}) \oplus H_{i-1}$ for $i = 0, 1, ..., t$, and $H(x) = H_t$
      \end{itemize}

    \subsection{Merkle Meta-Method}
      The Merkle meta-method is a technique for building iterated hash function using so-called compression functions. If the compression function $f$ is collision-resistant,
      then so is the hash function $H$, which is defined as follows:
        \begin{itemize}
          \item Let $H_0$ be some initializing value $IV$
          \item Let $f$ be a compressing function $f : \{0, 1\}^{n+r} \rightarrow \{0, 1\}^n$
          \item Let input $x$, which has a bitlength of less than $2^r$, be divided into $t$ r-bit blocks: $x = x_1x_2 . . . x_t$
          \item Let $x_{t+1}$ be the right-justified value of $b$. $x_{t+1}$ is referred to as a length block.
          \item $H_i = f(H_{i-1}, x_i)$ for $i = 0, 1, ..., t + 1$, and $H(x) = H_{t+1}$
        \end{itemize}

      The Merkle meta-method simplifies the problem of building collision-resistant hash functions to one of simply building collision-resistant compression functions.

    \subsection{Cryptographic Hash Functions in Production}
      MDx (e.g. MD4, MD5) is a family of 128-bit iterated hash functions. These functions have weak collision resistance and suffer from other vulnerabilities, so their use
      is declining.

      The Secure Hash Algorithm (SHA) family of iterated hash functions developed by the NSA and NIST. SHA-1 is a 160 bit hash, but due to a collision detection algorithm
      that takes around $2^{63}$ steps, it is being phased out in favor of the newer SHA-2 and SHA-3, which support custom hash lengths.

  \section{Message Authentication Code Schemes}

    \subsection{Formulation}
      A message authentication code (MAC) is a family of functions $H_k: \{0, 1\}^* \rightarrow \{0, 1\}^n$ parameterized with an $l$ bit key $k$. Each function $H_k$ should
      be possible to efficiently compute, and $H_k(x)$ is known as the tag or MAC of $x$ for the key $k$.

    \subsection{Applications}
      MAC schemes can be used to provide data integrity and data origin authentication. The high-level idea is that Alice and Bob agree to some secret key $k \in \{0, 1\}^l$.
      Alice can compute a tag $t = H_k(x)$ and send $(x, t)$ to Bob, and Bob verifies that $t = H_k(x)$. Since the adversary should not know the secret key $k$, this verification
      is used to confirm that the message was not altered, and if it is a new message, that it originated from Alice.

    \subsection{Security}
      Although the adversary does not know $k$, they are allowed to obtain $t$ for messages $(x, t)$ that were already sent. A MAC scheme is considered secure if it is
      computationally infeasible to compute $H_k(x_i)$ for some $x_i$ that has not yet been sent. For security purposes, each function in an ideal MAC scheme should act
      as a random function.

      Two generic types of attacks on MAC schemes are:
      \begin{itemize}
        \item \textbf{Guessing the MAC} of the message $x$. If $H_k(x) \in \{0, 1\}^n$ and $H_k$ acts as a random function, the probability of success is $\frac{1}{2^n}$.
        \item \textbf{Exhaustive key search}. If $k \in \{0, 1\}^l$, then there are $2^l$ possible keys.
      \end{itemize}

    \subsection{Block Cipher MACs}
      A common implementation of MACs using block ciphers is known as cipher block chaining MAC (CBC-MAC). The CBC-MAC algorithm is:
      \begin{enumerate}
        \item Divide a message $x$ into $n$ bit blocks $x_1, x_2, ..., x_n$.
        \item Compute $H_1 = E_k(x_1)$, where $k$ is the secret key and $E$ is a block cipher.
        \item For $i$ from $2$ to $r$, compute $H_i = E_k(H_{i-1} \oplus x)$.
        \item $H(x) = H_r$.
      \end{enumerate}

      If $E$ is a secure encryption scheme, then CBC-MAC is a secure MAC scheme assuming that fixed-length inputs are used. If variable-length messages are allowed, then
      CBC-MAC is susceptible to the following chosen-message attack:
      \begin{enumerate}
        \item Select an arbitrary $n$ bit block $x_1$.
        \item Obtain the tag $t_1 = E_k(x_1)$.
        \item Obtain the tag $t_2 = E_k(t_1)$. $t_2$ is the tag of the 2-block message $(x_1, 0)$, since $t_2 = E_k(0 \oplus E_k(x_1)) = E_k(E_k(x_1)) = E_k(t_1)$.
      \end{enumerate}

      Encrypted CBC-MAC is a variation of CBC-MAC where the last block is encrypted using a separate key $s$, and if $E$ is secure, encrypted CBC-MAC is secure for
      inputs of any length.

    \subsection{Hash Function MACs}
      Hash functions were not designed to be keyed, so it is not obvious how to use them to implement MACs. The high-level idea of ``keying'' hash functions is to
      incorporate the key in the input to the hash function.

      Let $H$ be a hash function with an $n$ bit message digest, and let $n + r$ be the input blocklength of its compression function $f: \{0, 1\}^{n+r} \rightarrow \{0, 1\}^n$.
      Let $k \in \{0, 1\}^n$ be the secret key, and let $K$ denote $k$ padded with $r - n$ 0s so that its bitlength is $r$. The key $k$ can be incorporated into hash functions
      as follows:

      \begin{itemize}
        \item \textbf{Secret Prefix Method:} $H_k(x) = H(K, x)$. This is insecure to a length-extension attack. Suppose $(x, H_k(x))$ is known, and suppose the bitlength of $x$
          is a multiple of $r$. Then $H(x || y)$ can be computed for any $y$ without knowledge of $k$.
        \item \textbf{Secret Suffix Method:} $H_k(x) = H(x, K)$. This method appears to be secure, provided that $H$ is collision resistant.
        \item \textbf{Envelope Method:} $H_k(x) = H(K, x, K)$. No exploits have been found for the envelope method.
      \end{itemize}

      \subsubsection{HMAC}
        HMAC stands for hash-based message authentication code. Given two $r$ bit string opad and ipad, HMAC is implemented as follows:

        $$H_k(x) = H(K \oplus opad, H(K \oplus ipad, x))$$

        If $H$ is a secure hash function, then HMAC is secure. It is used widely in practice, typically with SHA-256 as its hash function. HMAC is also commonly used as a key
        derivation function, where a secret key $k$ is used to compute several further session keys (e.g. $HMAC_k(1), HMAC_k(2), HMAC_k(3)$, etc). The keys appear to be randomly
        generated, so even if an adversary discovers information about one of them, the rest remain secret.

  \section{Authenticated Encryption}
    An encryption scheme can provide confidentiality, while a MAC scheme can provide data integrity and data origin authentication. Authenticated encryption combines an encryption
    scheme with a MAC scheme to provide all of these properties.

    \subsection{Common Implementations}
      \subsubsection{Encrypt-and-MAC}
        For an encryption function $E_{k_1}$ and a MAC function $H_{k_2}$, Alice sends $(c, t) = (E_{k_1}(m), H_{k_2}(m))$ to Bob. Bob obtains $m = E_{k_1}^{-1}(c)$, and then verifies
        that $t = H_{k_2}(m)$. While simple and intuitive, encrypt-and-MAC can have security vulnerabilities since there is no guarantee of data integrity on the ciphertext.

      \subsubsection{Encrypt-then-MAC}
        For an encryption function $E_{k_1}$ and a MAC function $H_{k_2}$, Alice sends $(c, t) = (E_{k_1}(m), H_{k_2}(E_{k_1}(m)))$ to Bob. Bob verifies that $t = H_{k_2}(c)$, and
        then obtains $m = E_{k_1}^{-1}(c)$. Provided that $E$ and $H$ are from secure encryption and MAC schemes, then the encrypt-then-MAC method is secure.

      \subsubsection{AES Galois/Counter Mod (GCM)}
        AES-GCM authenticated encryption. Suppose the data to be authenticated, but not encrypted is $A = (A_1, A_2, \dots, A_v)$, and the data to be both authenticated and encrypted
        is $M = (M_1, M_2, \dots, M_u)$. Let the secret key be $k \in \{0, 1\}^{128}$. AES-GCM is implemented as follows:

        \textbf{Alice:}
        \begin{enumerate}
          \item Let $L = L_A || L_M$, where $L_A, L_M$ are the bitlengths of $A, M$.
          \item Select $IV \in \{0, 1\}^{96}$ and let $J_0 = IV || 0^{31} || 1$.
          \item Encryption:
            \begin{enumerate}
              \item For $i = 1$ to $u$, $J_{i} = J_{i-1} + 1$ and $C_i = AES_{k}(J_i) \oplus M_i$.
            \end{enumerate}
          \item Authentication:
            \begin{enumerate}
              \item Let $T = 0^{128}$
              \item Compute $H = AES_k(0^{128})$.
              \item For $i = 1$ to $v$, $T = (T \oplus A_i) \cdot H$.
              \item For $i = 1$ to $u$, $T = (T \oplus C_i) \cdot H$.
              \item $T = (T \oplus L) \cdot H$.
              \item Compute $t = AES_k(J_0) \oplus T$.
            \end{enumerate}
          \item Output $(IV, A, C, T)$.
        \end{enumerate}

        \textbf{Bob:}
        \begin{enumerate}
          \item Let $L = L_A || L_M$, where $L_A, L_M$ are the bitlengths of $A, M$.
          \item Let $J_0 = IV || 0^{31} || 1$.
          \item Authentication:
            \begin{enumerate}
              \item Let $T = 0^{128}$
              \item Compute $H = AES_k(0^{128})$.
              \item For $i = 1$ to $v$, $T = (T \oplus A_i) \cdot H$.
              \item For $i = 1$ to $u$, $T = (T \oplus C_i) \cdot H$.
              \item $T = (T \oplus L) \cdot H$.
              \item Compute $t' = AES_k(J_0) \oplus T$.
              \item Accept if $t' = t$, else reject.
            \end{enumerate}
          \item Decryption:
            \begin{enumerate}
              \item For $i = 1$ to $u$, $J_{i} = J_{i-1} + 1$ and $M_i = AES_{k}(J_i) \oplus C_i$.
            \end{enumerate}
          \item Output $(A, M)$
        \end{enumerate}

        AES-GCM is secure, and because its encryption and decryption operations can be parallelized, it can be more efficient than algorithms such as encrypt-then-MAC. AES-GCM also
        supports authenticating but not encrypting pieces of data (e.g. a header section containing metadata).

\end{document}
